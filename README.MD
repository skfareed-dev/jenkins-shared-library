## Jenkins Shared Library Setup

### Overview

We implemented a Jenkins Shared Library to centralize and standardize CI/CD pipeline logic across multiple projects. This approach eliminates duplication, improves maintainability, and ensures consistent pipeline behavior for all services.

---

### What We Delivered

We created a reusable Jenkins Shared Library containing common pipeline stages as functions:

* **buildStage()**
  Handles application build logic (e.g., Maven/Gradle/npm build).

* **testStage()**
  Executes unit and integration tests with standardized reporting.

* **sonarScan()**
  Performs static code analysis using SonarQube and enforces quality gates.

* **dockerBuild()**
  Builds Docker images using a consistent tagging and build strategy.

* **pushToRegistry()**
  Pushes Docker images to the configured container registry (ECR / JFrog / Docker Hub).

* **notifySlack()**
  Sends pipeline status notifications (success/failure) to Slack channels.

---

### Key Design Highlights

* Pipeline logic is written once and reused across all Jenkins jobs.
* Application-specific Jenkinsfiles remain minimal and easy to read.
* Changes to CI/CD behavior can be done centrally without touching each repository.
* Encourages best practices and consistency across teams.

---

### Outcome

* **Standardized CI/CD stages** across multiple microservices and repositories.
* **Faster onboarding** for new projectsâ€”teams only need to call shared functions.
* **Reduced pipeline duplication**, leading to cleaner Jenkinsfiles.
* **Easier maintenance** since updates are managed in one central location.
* Improved reliability and governance of CI/CD workflows.

---

### Final Result

The Jenkins Shared Library acts as a single source of truth for CI/CD logic, enabling scalable, maintainable, and enterprise-ready pipeline management.
======================================================

Letâ€™s reduce it to the minimum possible code.

ğŸ¯ Goal

Jenkinsfile â†’ orchestration only

Shared library â†’ all logic, defaults, environment, tools

âœ… Ultra-Clean Jenkinsfile (BEST PRACTICE)
ğŸ”¹ Final Jenkinsfile (VERY LESS CODE)
@Library('ci-lib') _

pipeline {
    agent any

    stages {
        stage('CI') {
            steps {
                ciPipeline()
            }
        }
    }
}


Thatâ€™s it.
No env, no docker, no sonar, no nexus clutter.
This is how real enterprise pipelines look.

ğŸ§  Where did everything go?

â¡ï¸ Into the shared library.

ğŸ“¦ Shared Library Structure (Recommended)
jenkins-shared-library/
â”œâ”€â”€ vars/
â”‚   â”œâ”€â”€ ciPipeline.groovy
â”‚   â”œâ”€â”€ dockerBuild.groovy
â”‚   â”œâ”€â”€ sonarScan.groovy
â”‚   â”œâ”€â”€ pushToRegistry.groovy
â”‚   â”œâ”€â”€ buildStage.groovy
â”‚   â””â”€â”€ notifyEmail.groovy
â””â”€â”€ resources/

ğŸ”§ vars/ciPipeline.groovy (Core Orchestrator)
def call() {

    buildStage(this)

    sonarScan(
        this,
        env.SONAR_KEY,
        env.SONAR_ORG,
        'frontend,backend'
    )

    dockerBuild(
        this,
        env.BACKEND_IMAGE,
        env.FRONTEND_IMAGE,
        env.IMAGE_TAG
    )

    pushToRegistry(this, [
        registry      : env.NEXUS_REGISTRY,
        repo          : env.NEXUS_REPO,
        backendImage  : env.BACKEND_IMAGE,
        frontendImage : env.FRONTEND_IMAGE,
        tag           : env.IMAGE_TAG,
        credsId       : 'nexus-docker-creds'
    ])
}

ğŸŒ Global Defaults (One-time setup)
Jenkins â†’ Manage Jenkins â†’ Configure System â†’ Global Properties

Add Environment variables:

NEXUS_REGISTRY=13.251.194.219:8083
NEXUS_REPO=docker-hosted
BACKEND_IMAGE=node-backend
FRONTEND_IMAGE=node-frontend
SONAR_ORG=sonar00732
SONAR_KEY=sonar00732-NodeJS-Application


And in shared lib you can generate tag:

env.IMAGE_TAG = env.BUILD_NUMBER

ğŸ† Result
Before âŒ

60+ lines Jenkinsfile

Repeated env everywhere

Hard to maintain

After âœ…

8 lines Jenkinsfile

Centralized logic

Easy onboarding

Same pipeline for 10â€“100 repos

ğŸ’¬ Interview-ready explanation (IMPORTANT)

â€œOur Jenkinsfiles are intentionally thin.
All CI/CD logic is centralized in a shared library so teams only call ciPipeline() and donâ€™t worry about tooling, Docker, Sonar, or Nexus.â€